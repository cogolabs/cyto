<img src="logo.png" height="75"/>

A declarative boilerplate generator designed to help you write less meaningless code.

<Put a screen capture of some cool usage here>

## Installation

Cyto is primarily meant to be used as a global command line tool:

```bash
> yarn global add cyto
# or `npm install -g cyto`
> cyto init
```

It can also be used as a library in any node.js application (more on this later)

## What is Cyto
Cyto is a boilerplate generator. If you're unfamiliar with what that is, boilerplate code means code repeated in many places with little to no alteration. A boilerplate generator is a tool that can generate that code for you automatically, prompting you for any necessary information along the way.

The main problem Cyto aims to solve is how to generate the _correct_ amount of boilerplate while being flexible and easy to use. Many existing boilerplate projects lock you into another developer's preferences while giving you more than you need or not enough. Modifying them to fit your use case can, in some cases, be more work that starting from scratch. By providing a simple and consistent interface, Cyto provides a new and improved solution to generating boilerplate code.

## Getting Started
The core concept of Cyto is the generation of templates. Templates are user-created blueprints for boilerplate: they tell Cyto what to generate, what arguments to prompt the user for, and any special options to use. Each template is just a directory that contains a `cyto.config.js` file and any number of dependency files which hold boilerplate code to generate. All templates are stored in the global template library (abbreviated as GTL), which is a directory that you set when you run `cyto init`. The GTL also includes some examples to help you get started. Let's look at the `cyto/tutorial` template, which generates a single text file:

1. `/<path to GTL>/cyto/tutorial/cyto.config.js`
```js
module.exports = {
  templateId: "cyto/tutorial",
  dependencies: [
    '{{id}}.txt',
  ],
  args: [
    {
      id: 'thingToGreet',
      default: 'world',
    },
  ],
  options: {
    createDirectory: false,
  }
};
```
2. `/<path to GTL>/cyto/tutorial/{{id}}.txt`
```
Hello {{thingToGreet}}!

This file was generated by {{author}} using Cyto.
```

Even at it's simplest, there's a decent amount of information to process here, so let's break down each part starting with the `cyto.config.js` file. This file is the key piece of a Cyto template. It holds all of the relevant information about a template; every other file in a template can only contain boilerplate to generate. Each config must export an object with four keys:

1. `templateId`: A unique identifier for the template. This will determine where Cyto looks for the template in the GTL. Each `templateId` must be of the format `<group>/<name>`, where `group` is a logical grouping for related templates and `name` is a more specific descriptor for that template within the group. This template is in the `cyto` group and has a name of `tutorial`.
2. `dependencies`: An array that represents everything a template needs to be generated. Each dependency can be a string, an object, or a function (more on these later). In this template, we have one string dependency: `{{id}}.js`. This means Cyto will look for a file called `{{id}}.js` inside of the `cyto/tutorial` directory and output it when the template is generated.
3. `args`: An array of objects that represents all of the values that Cyto needs to get from a user in order to properly generate the template. Arguments can have a few different types (more on this later as well), but the default type is a string. The `cyto/hello` template only requires 1 argument, `thingToGreet`, which has a default value of `world`
4. `options`: An object that holds a collection of values to set while running Cyto. Here, we set the `createDirectory` flag to false, which tells Cyto not to create a new directory to hold all of the template's generated content (note: this is the default, it's just included for illustrative purposes)

The `{{id}}.txt` file, as mentioned above, is a dependency for the template and contains some boilerplate to generate. However, before this file is actually generated, it is passed through a [mustache](https://mustache.github.io/mustache.5.html) renderer to take the supplied arguments and insert them into the boilerplate. If you're unfamiliar with mustache, stop here and take a few minutes to familiarize yourself with the syntax. For the remainder of the documentation, *rendering* refers to passing some content through mustache while *generation* refers to the entire process of taking a Cyto template and writing it to the filesystem.

There are a few other things to mention about this template. For every string dependency, the filename is also passed through the mustache renderer. For this example, if the `id` argument is set to `hello`, the name of the rendered `{{id}}.txt` file will be `hello.txt`. All templates must be given a unique `id` arg at generation time, so you don't need to specify that in the args section of the `cyto.config.js` file. Cyto also provides the `author` variable by default. Finally, although the config file must be written in Javascript, the boilerplate that Cyto can generate is language independent. This means we can generate boilerplate for **any** kind of text file with just a bit of Javascript know-how.

Now that we understand how this Cyto template is structured, let's generate it! The command to generate a template is `cyto gen <templateId> <id>`, so generating the template above will look like this:

```bash
> cyto gen cyto/tutorial hello
Generating cyto/tutorial with id hello
? thingToGreet:  new Cyto user
> cat hello.txt
Hello new Cyto user!

This file was generated by Connor Taylor using Cyto.
```

And that's it! You've just generated your first boilerplate with Cyto. However, this is fairly trivial example. Cyto really starts to shine when you make use of its more advanced features, which will be explained in the rest of the documentation.

## Template Arguments

The `cyto/tutorial` template is great for explaining the core mechanics of Cyto but glosses over some important details. In this section, we're going to dive into more detail about the `args` section of a Cyto template, using the `cyto/argumentDemo` template to help demonstrate the different types of arguments Cyto accepts. Remember that the `args` section of each `cyto.config.js` file is just an array of objects that declares what values to prompt a user for at generation time. These values are then passed to mustache when each dependency is rendered. Let's take a look at an argument with all of the possible keys you can use:

```js
{
  id: 'demoArg',
  type: 'list', // default: string
  default: [] // default: undefined
  dontPrompt: false, // default: false
}
```

1. `id`: A unique identifier for an argument within a given template.
2. `type`: A string identifier for what type an argument is. Cyto supports four different types of arguments: `string` (default), `list`, `boolean`, and `function`.
3. `default`: A default value for the argument. Pretty self explanatory.
4. `dontPrompt`: A boolean flag that indicates if Cyto should avoid prompting the user for a value for this argument and use its default.

That's all there is to arguments! However, there are a couple caveats regarding `function` arguments. Let's take a look at the `functionArg` from the `cyto/argumentDemo` template:

```js
{
  id: 'functionArg',
  type: 'function',
  default: () => {
    return (text, render) => {
      return render(text)
        .then((renderedText) => {
          return renderedText.replace('Replace me', 'Got replaced');
        });
    }
  },
  dontPrompt: true
}
```

Currently, Cyto is unable to prompt the user for functions via the command line, so they must be provided via `default` and have `dontPrompt` set to `true`. Function arguments also look a bit different than how they are detailed in the mustache documentation. This is because Cyto uses a slightly modified version of [mustache.js](https://github.com/janl/mustache.js/) where the rendering process is asynchronous. This means that the `render` function returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with the rendered text, instead of returning the rendered text immediately. The reason behind this is due to how Cyto handles mustache partials, which will be explained in a later section. If you are familiar with [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) and are running a version of Node that supports them, you can express this in a much cleaner fashion:

```js
{
  id: 'functionArg',
  type: 'function',
  default: () => {
    return async (text, render) => {
      const renderedText = await render(text);
      return renderedText.replace('Replace me', 'Got replaced');
    }
  },
  dontPrompt: true
}
```

## Creating Your Own Templates

The final thing to cover before moving on to more complex concepts is how to create your own templates. Creating your own Cyto templates is just as important as generating them and is done via the `cyto create <templateId>` command:

```
> cyto create taylorc93/myFirstTemplate
Generating cyto/template with id taylorc93/myFirstTemplate
? files: someDependencyFile.js
? args:
> ls /path/to/GTL/taylorc93/myFirstTemplate
cyto.config.js        someDependencyFile.js
```

Under the hood, `cyto create` is just generating the `cyto/template` template. It's 99% equivalent to calling `cyto gen cyto/template <yourTemplateName>`, except that the generated template is written to the GTL instead of relative to where the command was run. This template accepts two list argument: `files` and `args`. `files` will both pre-populate the `dependencies` section of the new `cyto.config.js` file as well as create the boilerplate files the new template needs. `args` pre-populates the `args` section of the `cyto.config.js`. `cyto create` will also automatically place the template in the GTL for you.

## Composing Templates

One of the primary reasons that Cyto templates are so powerful is that they are composable, meaning that templates can have other templates as dependencies. This allows you to make templates that are much more modular and reusable. For those who are familiar with React, this design choice was heavily inspired by how React components work.

To indicate that a template depends on another template, we use object dependencies. Let's take a look at the `cyto/composing` template, which depends on the `cyto/composed` template:

`/<pathToGTL>/cyto/composing/cyto.config.js`
```js
module.exports = {
  templateId: "cyto/composing",
  dependencies: [
    'composing.txt',
    {
      templateId: 'cyto/composed',
      args: {
        id: 'composedTemplate',
        templateArg: 'I was passed via another template'
      }
    },
  ],
  args: [
    { id: 'userArg' },
  ],
  options: {
    createDirectory: false,
  }
};
```
`/<pathToGTL>/cyto/composing/composing.txt`
```
This template was given a userArg value of: {{userArg}}
```
`/<pathToGTL>/cyto/composed/cyto.config.js`
```js
module.exports = {
  templateId: "cyto/composed",
  dependencies: [
    'composed.txt',
  ],
  args: [
    { id: 'templateArg' },
    { id: 'userArg' }
  ],
  options: {
    createDirectory: false,
  }
};
```
`/<pathToGTL>/cyto/composed/composed.txt`
```
cyto/composed was generated by another template and given an id of: {{id}}

This template was given a userArg value of: {{userArg}}

The parent template supplied this value: {{templateArg}}
```

Object dependencies must have 2 keys: `templateId`, which specifies the template we need to generate, and `args`, which is an object that maps args to values. Cyto will not prompt the user for any arguments supplied this way. Since the `id` arg is required for all templates, it must be supplied by the parent template. This is what the generation of `cyto/composing` will look like:

```bash
> cyto gen cyto/composing compose
Generating cyto/composing with id compose
? userArg:  foo
Generating cyto/composed with id composedTemplate
? userArg:  bar
> cat composing.txt
This template was given a userArg value of: foo
> cat composed.txt
cyto/composed was generated by another template and given an id of: composedTemplate

This template was given a userArg value of: bar

The parent template supplied this value: I was passed via another template
```

Note that although both templates have an arg called `userArg`, they both get prompted for it. Cyto generates each template independently, so one set of args doesn't clobber another.

## Runtime dependencies

If you created your own Cyto template earlier, you'll remember that creating a new template is, under the hood, generating the `cyto/template` template. One of the arguments this template takes is a list argument called `files` , which creates an empty file for each value in the list. But how did the `cyto/template` template declare those file dependencies if it only knows what files it needs at generation time after the user has supplied the required args? The answer is runtime dependencies.

A runtime dependency is a function (remember, dependencies can be strings, objects, or functions) placed in the `dependencies` section of `cyto.config.js` that takes the args supplied to the template at generation time and returns a new set of dependencies. This set can be one of four things: a single string, a single object, a list of strings, or a list of objects. Lets take a look at the `cyto.config.js` file for the `cyto/template`:

```js
module.exports = {
  templateId: "cyto/template",
  dependencies: [
    '{{name}}.js',
    (args) => args.files.map((f) => f.id),
  ],
  args: [
    {
      id: 'name',
      type: 'string',
      default: 'cyto.config',
      dontPrompt: true
    },
    {
      id: 'files',
      type: 'list',
      default: []
    },
    {
      id: 'args',
      type: 'list',
      default: []
    }
  ],
  options: {
    createDirectory: true
  }
};
```

As you can see, this template has 2 dependencies, `{{name}}.js`, which represents the `cyto.config.js` file to create for the new template, and a function. All this function does is [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the `args.files` array and returns a new array of strings. Each string in this new array represents an empty file to create and is merged into the existing set of dependencies automatically.

## Partial Templates

Section about how to use mustache partials in conjunction with Cyto templates

## Base Templates

Section about how to specify a base template and what that does

## Publishing / Downloading Templates

What utilities there are for downloading other people's Cyto templates

## Template options

Explanation of all of the values that can be set in the `options` object of a `cyto.config.js` file. Currently, they are `createDirectory`, `skipRendering`, `preGeneration`, and `postGeneration`.

## Best Practices

Section describing the best practices of using Cyto

## Contributing
1. Read the docs on contributing [here](CONTRIBUTING.md) and sign the CLA
1. Clone this repository
1. Run `yarn` or `npm i`
1. Run `npm run watch` and leave it running
1. Run `npm link` in a separate terminal
1. You should now have the cyto command installed! It will update with your latest changes while you have `npm watch` active

Written by: Connor Taylor [@taylorc93](https://github.com/taylorc93)
